<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Security-Policy" content="default-src * 'unsafe-inline' 'unsafe-eval' data: blob:;">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="theme-color" content="#000000">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="manifest" href="manifest.json">
    <title>JARVIS: MOBILE UNIT</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- TENSORFLOW & MODELS -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/blazeface"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet"></script>

    <style>
        :root {
            --primary: #00E5FF;
            --secondary: rgba(0, 229, 255, 0.2);
            --bg-color: #000000;
            --safe-top: env(safe-area-inset-top);
            --safe-bottom: env(safe-area-inset-bottom);
        }

        * { -webkit-tap-highlight-color: transparent; user-select: none; box-sizing: border-box; outline: none; }
        html, body { margin: 0; padding: 0; overflow: hidden; background-color: var(--bg-color); font-family: 'Orbitron', sans-serif; color: var(--primary); height: 100vh; width: 100vw; display: flex; justify-content: center; align-items: center; touch-action: none; overscroll-behavior: none; }
        
        /* BACKGROUND */
        #reactor-container { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 100vw; height: 100vh; z-index: 0; opacity: 0.8; pointer-events: none; }
        canvas { display: block; }
        
        /* --- VISION SYSTEM --- */
        #vision-container {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: #000; z-index: 200; display: none;
            flex-direction: column; align-items: center; justify-content: center;
        }

        #vision-feed-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; background: #000; }
        #local-vision-feed { width: 100%; height: 100%; object-fit: cover; }
        #local-vision-feed.mirrored { transform: scaleX(-1); }
        #vision-ar-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 20; pointer-events: none; }

        .vision-controls-bar {
            position: absolute; bottom: 40px; width: 100%;
            display: flex; justify-content: center; gap: 20px; pointer-events: auto; z-index: 50;
        }
        .v-btn {
            background: rgba(0,0,0,0.6); border: 1px solid var(--primary);
            color: var(--primary); border-radius: 50%; width: 60px; height: 60px;
            display: flex; align-items: center; justify-content: center;
            font-size: 20px; box-shadow: 0 0 15px var(--secondary); cursor: pointer;
            backdrop-filter: blur(5px);
        }
        .v-btn:active { transform: scale(0.95); background: rgba(0, 229, 255, 0.2); }
        .v-btn.recording { border-color: red; color: red; animation: pulse-red 1s infinite; }
        @keyframes pulse-red { 0% { box-shadow: 0 0 0 rgba(255,0,0,0.5); } 70% { box-shadow: 0 0 20px rgba(255,0,0,0); } 100% { box-shadow: 0 0 0 rgba(255,0,0,0); } }

        /* --- MOTO HUD --- */
        #moto-hud {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: #000; z-index: 300; display: none; flex-direction: column;
            color: var(--primary); font-family: 'Share Tech Mono', monospace;
            padding-top: max(10px, var(--safe-top));
            padding-bottom: max(10px, var(--safe-bottom));
        }
        .hud-top { height: 60px; border-bottom: 2px solid var(--primary); display: flex; align-items: center; justify-content: center; overflow: hidden; position: relative; background: rgba(0, 229, 255, 0.05); flex-shrink: 0; }
        .compass-tape { display: flex; gap: 60px; font-size: 22px; font-weight: bold; transition: transform 0.1s linear; color: var(--primary); will-change: transform; }
        .compass-marker { position: absolute; bottom: 0; width: 0; height: 0; border-left: 10px solid transparent; border-right: 10px solid transparent; border-bottom: 12px solid var(--primary); z-index: 5; }
        .hud-mid { flex: 1; position: relative; overflow: hidden; display: flex; align-items: center; justify-content: center; }
        
        /* New HUD Gauge Canvas replaces CSS elements */
        #hud-gauge-canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;}
        
        /* Removed Crosshair CSS */

        .hud-bot { height: 80px; display: flex; justify-content: space-between; align-items: center; padding: 0 30px; border-top: 1px solid var(--primary); background: rgba(0,0,0,0.9); flex-shrink: 0; z-index: 20; }
        .hud-btn { background: rgba(0, 229, 255, 0.1); border: 1px solid var(--primary); color: var(--primary); width: 60px; height: 60px; border-radius: 10px; display: flex; align-items: center; justify-content: center; font-size: 24px; }
        .hud-time { font-size: 32px; font-weight: bold; color: #fff; }

        /* GENERAL UI */
        #start-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 9999; display: flex; flex-direction: column; justify-content: center; align-items: center; }
        #start-btn { padding: 20px 40px; border: 1px solid var(--primary); color: var(--primary); font-family: 'Orbitron'; font-size: 18px; font-weight: 900; animation: pulse 2s infinite; cursor: pointer; }
        @keyframes pulse { 0% { box-shadow: 0 0 10px var(--secondary); } 50% { box-shadow: 0 0 25px var(--primary); border-color: #fff; } 100% { box-shadow: 0 0 10px var(--secondary); } }

        /* MODALS */
        .modal-window { 
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            background: rgba(5, 8, 12, 0.98); backdrop-filter: blur(10px); z-index: 100; 
            display: flex; flex-direction: column; transform: translateY(110%);
            transition: transform 0.4s ease; padding-top: var(--safe-top);
        }
        .modal-window.active { transform: translateY(0); }
        .modal-header { padding: 20px; border-bottom: 1px solid var(--secondary); display: flex; justify-content: space-between; align-items: center; flex-shrink: 0;}
        .modal-body { padding: 20px; overflow-y: auto; flex: 1; display: flex; flex-direction: column; gap: 15px; }

        /* DB & MEDIA */
        .db-entry { border: 1px solid var(--secondary); padding: 10px; border-radius: 5px; display: flex; gap: 10px; align-items: center; }
        .db-img { width: 50px; height: 50px; border-radius: 50%; object-fit: cover; border: 1px solid var(--primary); }
        input { background: #111; border: 1px solid #333; color: var(--primary); padding: 15px; width: 100%; font-family: 'Share Tech Mono'; margin-bottom: 10px; }
        .text-btn { padding: 15px; background: rgba(0, 229, 255, 0.1); border: 1px solid var(--primary); color: var(--primary); font-family: 'Orbitron'; font-weight: bold; width: 100%; }
        .text-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* PLAYLIST STYLES */
        #playlist-container { flex: 1; overflow-y: auto; margin-top: 10px; border-top: 1px solid rgba(0,229,255,0.3); scrollbar-width: thin; scrollbar-color: var(--primary) transparent; }
        #playlist-container::-webkit-scrollbar { width: 5px; }
        #playlist-container::-webkit-scrollbar-thumb { background: var(--primary); border-radius: 2px; }
        .track-item { padding: 12px; border-bottom: 1px solid rgba(255,255,255,0.05); cursor: pointer; font-family: 'Share Tech Mono'; font-size: 14px; color: #888; transition: all 0.2s; display: flex; align-items: center; gap: 10px; }
        .track-item:hover { background: rgba(0, 229, 255, 0.05); color: #ccc; }
        .track-item.active-track { color: var(--primary); background: rgba(0, 229, 255, 0.1); border-left: 3px solid var(--primary); }
        .track-icon { width: 20px; text-align: center; }

        /* COMMS GRID */
        .comms-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 20px; }
        .comms-btn {
            background: rgba(0, 20, 40, 0.8); border: 1px solid var(--primary); border-radius: 10px;
            padding: 20px; display: flex; flex-direction: column; align-items: center; gap: 10px;
            cursor: pointer; transition: all 0.2s;
        }
        .comms-btn:active { background: var(--primary); color: #000; }
        .comms-icon { font-size: 32px; color: var(--primary); }
        .comms-btn:active .comms-icon { color: #000; }
        .comms-label { font-size: 12px; font-family: 'Orbitron'; letter-spacing: 1px; }

    </style>
</head>
<body>

    <!-- STARTUP -->
    <div id="start-overlay" onclick="initSystem()">
        <div style="font-size: 50px; color: var(--primary); margin-bottom: 20px;"><i class="fas fa-fingerprint"></i></div>
        <div id="start-btn">INITIALIZE JARVIS</div>
        <div style="margin-top: 20px; font-size: 12px; font-family: 'Share Tech Mono'; opacity: 0.6;">T-FORCE SECURITY PROTOCOLS</div>
        <div id="model-status" style="margin-top:20px; font-size: 12px; color: #FFA500;">LOADING NEURAL NETWORKS...</div>
    </div>

    <!-- MAIN REACTOR (BACKGROUND) -->
    <div id="reactor-container"><canvas id="reactor"></canvas></div>

    <!-- MOTO HUD -->
    <div id="moto-hud">
        <div class="hud-top">
            <div class="compass-marker"></div>
            <div class="compass-tape" id="hud-compass">
                <span>N</span><span>NE</span><span>E</span><span>SE</span><span>S</span><span>SW</span><span>W</span><span>NW</span><span>N</span><span>NE</span><span>E</span>
            </div>
        </div>
        <div class="hud-mid">
            <!-- CANVAS REACTOR LAYER -->
            <canvas id="hud-gauge-canvas"></canvas>
        </div>
        <div class="hud-bot">
            <div class="hud-btn" onclick="closeHUD()"><i class="fas fa-home"></i></div>
            <div class="hud-time" id="hud-clock">00:00</div>
            <div class="hud-btn" onclick="launchMaps()"><i class="fas fa-location-arrow"></i></div>
        </div>
    </div>

    <!-- VISION SYSTEM -->
    <div id="vision-container">
        <div id="vision-feed-layer"><video id="local-vision-feed" autoplay playsinline muted></video></div>
        <canvas id="vision-ar-canvas"></canvas>
        <div id="cam-error-msg" style="position:absolute; top:50%; left:50%; transform:translate(-50%,-50%); width:100%; text-align:center; display:none; z-index: 100;"><i class="fas fa-exclamation-triangle" style="font-size:40px; color:var(--primary); margin-bottom:10px;"></i><br>VIDEO SIGNAL LOST</div>
        <div class="vision-controls-bar">
            <div class="v-btn" onclick="toggleCameraSource()" title="Switch Cam"><i class="fas fa-sync-alt"></i></div>
            <div class="v-btn" onclick="takePhoto()" title="Take Photo"><i class="fas fa-camera"></i></div>
            <div class="v-btn" id="btn-record" onclick="toggleRecord()" title="Record Video"><i class="fas fa-video"></i></div>
            <div class="v-btn" onclick="closeVision()" title="Close"><i class="fas fa-times"></i></div>
        </div>
        <div style="position: absolute; top: 10px; width: 100%; text-align: center; z-index: 50; text-shadow: 0 0 5px #000;">
            <div style="font-size: 14px; letter-spacing: 2px; color: var(--primary);" id="vision-status">SYSTEM ONLINE</div>
        </div>
    </div>

    <!-- MODAL: FACE DB -->
    <div id="modal-db" class="modal-window">
        <div class="modal-header"><span>IDENTITY DATABASE</span><i class="fas fa-times" style="font-size: 24px;" onclick="closeModal('modal-db')"></i></div>
        <div class="modal-body">
            <div style="text-align: center;"><img id="db-preview" style="width:120px; height:120px; border-radius:50%; border:2px solid var(--primary); object-fit:cover;"></div>
            <input type="text" id="db-name" placeholder="FULL NAME">
            <input type="text" id="db-relation" placeholder="RELATION (e.g. Wife)">
            <div id="signature-status" style="font-size:10px; color:#FFA500; margin-bottom:10px; text-align:center;">TAKE PHOTO TO EXTRACT SIGNATURE</div>
            <button class="text-btn" id="btn-save-id" onclick="saveIdentity()" disabled>SAVE IDENTITY</button>
            <div style="border-top:1px solid #333; margin-top:20px; padding-top:10px; font-size:12px;">KNOWN ASSOCIATES:</div>
            <div id="db-list" style="display:flex; flex-direction:column; gap:10px;"></div>
            <button class="text-btn" style="margin-top:20px; background:rgba(255,0,0,0.2); border-color:red; color:red;" onclick="clearDB()">WIPE DATABASE</button>
        </div>
    </div>

    <!-- MODAL: COMMS -->
    <div id="modal-comms" class="modal-window">
        <div class="modal-header"><span>SECURE COMMS</span><i class="fas fa-times" style="font-size: 24px;" onclick="closeModal('modal-comms')"></i></div>
        <div class="modal-body">
            <div class="comms-grid">
                <div class="comms-btn" onclick="launchApp('whatsapp://send?text=')">
                    <i class="fab fa-whatsapp comms-icon"></i>
                    <span class="comms-label">WHATSAPP</span>
                </div>
                <div class="comms-btn" onclick="launchApp('https://m.me/')">
                    <i class="fab fa-facebook-messenger comms-icon"></i>
                    <span class="comms-label">MESSENGER</span>
                </div>
                <div class="comms-btn" onclick="launchApp('https://m.facebook.com/')">
                    <i class="fab fa-facebook-f comms-icon"></i>
                    <span class="comms-label">FACEBOOK</span>
                </div>
                <div class="comms-btn" onclick="launchApp('https://www.instagram.com/')">
                    <i class="fab fa-instagram comms-icon"></i>
                    <span class="comms-label">INSTAGRAM</span>
                </div>
            </div>
            <div style="margin-top:auto; font-size:10px; color:#666; text-align:center;">ENCRYPTED CHANNELS READY</div>
        </div>
    </div>

    <!-- MODAL: SETTINGS -->
    <div id="modal-settings" class="modal-window">
        <div class="modal-header"><span>CONFIG</span><i class="fas fa-times" style="font-size: 24px;" onclick="closeModal('modal-settings')"></i></div>
        <div class="modal-body">
            <div style="font-size: 12px; color: #888;">GEMINI API KEY</div>
            <input type="password" id="api-key-input" onchange="saveApiKey(this.value)">
            <button class="text-btn" onclick="openModal('modal-db')">MANAGE DATABASE</button>
            <button class="text-btn" onclick="requestFullScreen()">FORCE FULLSCREEN</button>
        </div>
    </div>

    <!-- MODAL: MEDIA -->
    <div id="modal-media" class="modal-window">
        <div class="modal-header"><span>MEDIA LINK</span><i class="fas fa-times" style="font-size: 24px;" onclick="closeModal('modal-media')"></i></div>
        <div class="modal-body">
            <input type="file" id="media-upload" accept="audio/*" multiple onchange="handleMediaSelect(this)" style="display:none;">
            <button class="text-btn" onclick="document.getElementById('media-upload').click()">
                <i class="fas fa-plus"></i> ADD AUDIO FILES
            </button>
            <div style="background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; margin-top: 10px; border: 1px solid rgba(0,229,255,0.2);">
                <div id="now-playing" style="color: var(--primary); font-size: 12px; margin-bottom: 5px; text-align: center;">NO MEDIA</div>
                <audio id="audio-player" controls style="width:100%; height: 30px; filter: invert(1) hue-rotate(180deg);"></audio>
            </div>
            <div style="font-size: 10px; color: #888; margin-top: 10px;">PLAYLIST</div>
            <button class="text-btn" style="margin-top:5px; font-size:10px; padding:5px; width:auto; border-color:red; color:red;" onclick="clearMediaDB()">CLEAR PLAYLIST</button>
            <div id="playlist-container">
                <div style="text-align:center; padding: 20px; color: #444; font-size: 12px;">PLAYLIST EMPTY</div>
            </div>
        </div>
    </div>

    <script>
        /* --- SYSTEM CORE --- */
        const canvas = document.getElementById('reactor');
        const ctx = canvas.getContext('2d');
        
        let width, height, centerX, centerY, scale, time = 0;
        let animationFrame;
        
        let systemConfig = { apiKey: localStorage.getItem('jarvis_api_key') || '' };
        let facesDB = JSON.parse(localStorage.getItem('jarvis_faces') || '[]');
        
        let visionActive = false;
        let hudActive = false;
        // HUD SENSOR DATA (ADDED: alt, batt)
        let hudData = { alpha: 0, beta: 0, gamma: 0, speed: 0, alt: 0, batt: 100 };
        
        let localStream = null;
        let audioCtx, recognition;
        let watchId = null;
        let camFacingMode = 'environment';
        let playlist = []; 
        let currentTrackIndex = -1;

        // Recording
        let mediaRecorder;
        let recordedChunks = [];
        let isRecording = false;

        // AI Models
        let faceModel = null;
        let recogModel = null;
        let isModelLoaded = false;
        let pendingEmbedding = null;
        
        // --- TACTICAL TRACKING STATE (INTERPOLATED) ---
        let lockedTarget = { active: false, x: 0, y: 0, identity: null, lastSeen: 0, color: "#888888" };
        let isAnalyzing = false;

        // MENU CONFIG 
        const menuItems = [
            { id: 'media', label: 'MEDIA', icon: 'fa-folder', target: 'sub-toggle', angle: -Math.PI * 0.8 }, 
            { id: 'config', label: 'CONFIG', icon: 'fa-cog', target: 'modal-settings', angle: -Math.PI * 0.4 }, 
            { id: 'vision', label: 'VISION', icon: 'fa-eye', target: 'vision-toggle', angle: Math.PI * 0.4 },
            { id: 'hud', label: 'HUD', icon: 'fa-motorcycle', target: 'hud-launch', angle: Math.PI * 0.8 }
        ];

        // SUB-MENU STATE
        let mediaSubMenuOpen = false;
        const subMenuItems = [
            { id: 'sub-player', label: 'PLAYER', icon: 'fa-music', target: 'modal-media', angle: -Math.PI * 0.95 },
            { id: 'sub-comms', label: 'COMMS', icon: 'fa-comments', target: 'modal-comms', angle: -Math.PI * 0.65 }
        ];

        /* --- INDEXED DB --- */
        let db; const DB_NAME = 'JarvisMediaDB'; const DB_VERSION = 1; const STORE_NAME = 'tracks';
        function initMediaDB() { const request = indexedDB.open(DB_NAME, DB_VERSION); request.onupgradeneeded = (e) => { const db = e.target.result; if (!db.objectStoreNames.contains(STORE_NAME)) db.createObjectStore(STORE_NAME, { autoIncrement: true }); }; request.onsuccess = (e) => { db = e.target.result; loadTracksFromDB(); }; }
        function saveTrackToDB(file) { if (!db) return; const t = db.transaction([STORE_NAME], 'readwrite'); t.objectStore(STORE_NAME).add(file); }
        function loadTracksFromDB() { if (!db) return; const t = db.transaction([STORE_NAME], 'readonly'); const r = t.objectStore(STORE_NAME).getAll(); r.onsuccess = () => { if (r.result && r.result.length > 0) { playlist = r.result; renderPlaylist(); speak(`Media Database loaded. ${playlist.length} tracks.`); } }; }
        function clearMediaDB() { if (!db) return; const t = db.transaction([STORE_NAME], 'readwrite'); t.objectStore(STORE_NAME).clear(); playlist = []; renderPlaylist(); speak("Playlist cleared."); }

        /* --- INIT --- */
        async function initSystem() {
            if ('wakeLock' in navigator) try { await navigator.wakeLock.request('screen'); } catch (e) {}
            audioCtx = new (window.AudioContext || window.webkitAudioContext)(); if (audioCtx.state === 'suspended') audioCtx.resume();
            
            // BATTERY LISTENER
            if('getBattery' in navigator) {
                navigator.getBattery().then(b => {
                    hudData.batt = Math.round(b.level * 100);
                    b.addEventListener('levelchange', () => { hudData.batt = Math.round(b.level * 100); });
                });
            }

            initMediaDB();
            try { faceModel = await blazeface.load(); recogModel = await mobilenet.load(); isModelLoaded = true; document.getElementById('model-status').innerText = "SYSTEM READY"; document.getElementById('model-status').style.color = "#00E5FF"; setTimeout(() => document.getElementById('start-overlay').style.display = 'none', 1000); } 
            catch (e) { document.getElementById('model-status').innerText = "AI ERROR: CHECK NETWORK"; document.getElementById('model-status').style.color = "red"; setTimeout(() => document.getElementById('start-overlay').style.display = 'none', 3000); }
            if(systemConfig.apiKey) document.getElementById('api-key-input').value = systemConfig.apiKey;
            document.getElementById('audio-player').onended = playNextTrack;
            loadFaceDB(); resize(); draw(); 
            setTimeout(() => { initSpeech(); speak("Welcome back, Jim. System secure."); }, 500);
            if ('serviceWorker' in navigator) navigator.serviceWorker.register('/jarvis-uplink/sw.js', { scope: '/jarvis-uplink/' }).catch(e => console.log('SW Fail', e));
        }
        function requestFullScreen() { const doc = document.documentElement; if (doc.requestFullscreen) doc.requestFullscreen(); else if (doc.webkitRequestFullscreen) doc.webkitRequestFullscreen(); }
        window.addEventListener('resize', resize);
        
        function resize() { 
            width = window.innerWidth; 
            height = window.innerHeight; 
            canvas.width = width; 
            canvas.height = height; 
            centerX = width / 2; 
            centerY = height / 2; 
            scale = Math.min(width, height) * (width < 768 ? 0.35 : 0.22); 
            
            const arCvs = document.getElementById('vision-ar-canvas'); 
            arCvs.width = width; arCvs.height = height;
            
            const hudCvs = document.getElementById('hud-gauge-canvas');
            if(hudCvs) { hudCvs.width = document.querySelector('.hud-mid').offsetWidth; hudCvs.height = document.querySelector('.hud-mid').offsetHeight; }
        }
        
        function lerp(s, e, a) { return (1 - a) * s + a * e; }

        function drawReactor(context, x, y, r, t, isBg, colorOverride) {
            const mainColor = colorOverride || '#00E5FF'; const secondaryColor = colorOverride ? colorOverride : 'rgba(0, 229, 255, 0.5)'; const orange = '#FFA500';
            context.setTransform(1,0,0,1,0,0); if(isBg) context.clearRect(0,0, width, height); context.translate(x, y);
            context.save(); context.rotate(t * 0.0005); for (let i = 0; i < 60; i++) { context.rotate(Math.PI * 2 / 60); context.beginPath(); context.moveTo(r*1.0,0); context.lineTo(r*1.1,0); context.strokeStyle = mainColor; context.lineWidth = 1; context.stroke(); } context.restore();
            context.save(); context.rotate(-t * 0.001); context.lineWidth = r * 0.12; context.strokeStyle = secondaryColor; for(let j=0; j<3; j++) { context.beginPath(); context.arc(0, 0, r*0.85, 0, 1.2); context.stroke(); context.rotate(Math.PI*2/3); } context.restore();
            context.save(); context.rotate(t * 0.002); context.strokeStyle = mainColor; context.lineWidth = 2; context.beginPath(); context.arc(0,0, r*0.75, 0, Math.PI*2); context.stroke(); context.restore();
            context.save(); context.rotate(-t * 0.003); context.lineWidth = r * 0.1; context.strokeStyle = mainColor; for(let l=0; l<2; l++) { context.beginPath(); context.arc(0,0, r*0.65, 0, 2.0); context.stroke(); context.rotate(Math.PI); } context.restore();
            if(!colorOverride) { context.save(); context.rotate(t * 0.01); context.lineWidth = 6; context.strokeStyle = orange; context.shadowColor = orange; context.shadowBlur = 15; context.beginPath(); context.arc(0,0, r*0.55, 0, 2.0); context.stroke(); context.restore(); }
            context.save(); context.rotate(t * 0.02); context.lineWidth = 3; context.strokeStyle = '#FFFFFF'; context.shadowColor = '#FFFFFF'; context.shadowBlur = 10; context.beginPath(); context.arc(0,0, r*0.45, 0, Math.PI*2); context.stroke(); context.restore();
        }

        // --- NEW HUD REACTOR DRAW LOGIC (MARK III) ---
        function drawHUDGauge() {
            const hCvs = document.getElementById('hud-gauge-canvas');
            if(!hCvs) return;
            const hCtx = hCvs.getContext('2d');
            const hW = hCvs.width; const hH = hCvs.height;
            const hCX = hW / 2; const hCY = hH / 2;
            
            // REDUCED SCALE (0.30 instead of 0.40)
            const rad = Math.min(hW, hH) * 0.30; 
            
            // FIX: Reset transform before clearing
            hCtx.setTransform(1, 0, 0, 1, 0, 0);
            hCtx.clearRect(0,0, hW, hH);
            
            // DYNAMIC COLOR BASED ON SPEED
            let speedColor = '#00E5FF';
            let speed = hudData.speed;
            if(speed > 50 && speed <= 100) speedColor = '#00FF00'; // Green
            else if(speed > 100 && speed <= 150) speedColor = '#FFA500'; // Orange
            else if(speed > 150) speedColor = '#FF0000'; // Red

            // 1. Static Reactor Ring (Outer) - PASSING CENTER COORDS
            drawReactor(hCtx, hCX, hCY, rad, time, false, speedColor);
            
            // RESET TRANSFORM TO CENTER
            hCtx.setTransform(1,0,0,1,0,0);
            hCtx.translate(hCX, hCY);
            
            // 2. Compass Ring (MOVED OUTSIDE)
            hCtx.save();
            const compassRad = -hudData.alpha * (Math.PI / 180);
            hCtx.rotate(compassRad);
            
            hCtx.strokeStyle = speedColor;
            hCtx.fillStyle = speedColor;
            hCtx.font = `bold ${rad*0.25}px Share Tech Mono`; // Increased font slightly
            hCtx.textAlign = 'center';
            hCtx.textBaseline = 'middle';
            
            const directions = ['N', 'E', 'S', 'W'];
            for(let i=0; i<4; i++) {
                hCtx.save();
                hCtx.rotate(i * (Math.PI/2)); 
                // PUSH OUTSIDE THE RING (Radius * 1.25)
                hCtx.translate(0, -rad * 1.35); 
                hCtx.rotate(-i * (Math.PI/2)); 
                hCtx.fillText(directions[i], 0, 0);
                hCtx.restore();
            }
            hCtx.restore();

            // 3. Artificial Horizon (Inner Reactor Core)
            hCtx.save();
            const rollRad = -hudData.gamma * (Math.PI / 180); 
            const pitchY = hudData.beta * 3; 
            
            hCtx.rotate(rollRad);
            hCtx.translate(0, pitchY);
            
            // Horizon Line
            hCtx.strokeStyle = '#FFFFFF';
            hCtx.lineWidth = 3;
            hCtx.shadowBlur = 10;
            hCtx.shadowColor = speedColor;
            hCtx.beginPath(); hCtx.moveTo(-rad*0.6, 0); hCtx.lineTo(rad*0.6, 0); hCtx.stroke();
            
            // Pitch Ladder
            hCtx.lineWidth = 1;
            hCtx.globalAlpha = 0.5;
            for(let i=1; i<=3; i++) {
                hCtx.beginPath(); hCtx.moveTo(-rad*0.3, -i*30); hCtx.lineTo(rad*0.3, -i*30); hCtx.stroke(); 
                hCtx.beginPath(); hCtx.moveTo(-rad*0.3, i*30); hCtx.lineTo(rad*0.3, i*30); hCtx.stroke(); 
            }
            hCtx.restore();

            // 4. Speedometer (Static Center)
            hCtx.shadowBlur = 0;
            hCtx.fillStyle = '#FFFFFF';
            hCtx.font = `900 ${rad*0.6}px Orbitron`;
            hCtx.textAlign = 'center';
            hCtx.textBaseline = 'middle';
            hCtx.fillText(hudData.speed, 0, 10);
            
            hCtx.font = `bold ${rad*0.15}px Share Tech Mono`;
            hCtx.fillStyle = speedColor;
            hCtx.fillText("KM/H", 0, rad*0.45);

            // 5. PERIPHERAL TELEMETRY (FIXED POSITIONS)
            // We use SetTransform to draw in absolute screen coordinates, ignoring rotation
            hCtx.setTransform(1, 0, 0, 1, 0, 0); 
            
            hCtx.font = `bold ${rad*0.25}px Share Tech Mono`;
            hCtx.shadowBlur = 0;

            // ALTITUDE (Sides)
            hCtx.fillStyle = '#FFFFFF';
            hCtx.textAlign = 'left';
            hCtx.fillText(`ALT`, 20, hCY - 20); 
            hCtx.fillText(`${Math.round(hudData.alt)}m`, 20, hCY + 10); // Left Side

            hCtx.textAlign = 'right';
            hCtx.fillText(`ALT`, hW - 20, hCY - 20); 
            hCtx.fillText(`${Math.round(hudData.alt)}m`, hW - 20, hCY + 10); // Right Side

            // BATTERY (Top Right Corner)
            hCtx.fillStyle = hudData.batt < 20 ? '#FF0000' : '#00E5FF';
            hCtx.textAlign = 'right';
            hCtx.fillText(`PWR ${hudData.batt}%`, hW - 20, 40);

            // LEAN ANGLE (Bottom Corners)
            hCtx.fillStyle = '#FFFFFF';
            let lean = Math.round(hudData.gamma);
            let leanText = (lean > 0) ? `R ${lean}°` : `L ${Math.abs(lean)}°`;
            if(Math.abs(lean) < 2) leanText = "--°";
            
            hCtx.textAlign = 'left';
            hCtx.fillText(`BANK`, 20, hH - 40);
            hCtx.fillText(leanText, 20, hH - 15); // Bottom Left

            hCtx.textAlign = 'right';
            hCtx.fillText(`BANK`, hW - 20, hH - 40);
            hCtx.fillText(leanText, hW - 20, hH - 15); // Bottom Right
        }

        function drawTacticalHUD(ctx, x, y, r, t, color, name, relation) {
            ctx.save(); ctx.translate(x, y);
            ctx.save(); ctx.rotate(t * 0.02); ctx.strokeStyle = color; ctx.lineWidth = 2; for(let i=0; i<3; i++) { ctx.beginPath(); ctx.arc(0, 0, r * 0.6, 0, 1.5); ctx.stroke(); ctx.rotate((Math.PI * 2) / 3); } ctx.restore();
            ctx.save(); ctx.rotate(-t * 0.015); ctx.strokeStyle = color; ctx.lineWidth = 2; for(let i=0; i<2; i++) { ctx.beginPath(); ctx.arc(0, 0, r * 0.8, 0, 2.0); ctx.stroke(); ctx.rotate(Math.PI); } ctx.restore();
            ctx.save(); ctx.rotate(t * 0.005); ctx.strokeStyle = color; ctx.lineWidth = 4; ctx.globalAlpha = 0.6; ctx.beginPath(); ctx.arc(0, 0, r * 1.0, 0, Math.PI*2); ctx.stroke(); ctx.restore();
            ctx.save(); ctx.beginPath(); ctx.moveTo(r, 0); ctx.lineTo(r + 30, -30); ctx.lineTo(r + 150, -30); ctx.strokeStyle = color; ctx.lineWidth = 1; ctx.stroke();
            ctx.fillStyle = color; ctx.font = "14px Share Tech Mono"; ctx.textAlign = "left"; ctx.shadowColor = color; ctx.shadowBlur = 5; ctx.fillText(name, r + 35, -35); ctx.font = "12px Share Tech Mono"; ctx.fillText(relation, r + 35, -15); ctx.restore(); ctx.restore();
        }

        async function draw() {
            if(hudActive) { 
                drawHUDGauge();
                animationFrame = requestAnimationFrame(draw); 
                return; 
            }
            if(!visionActive) { drawReactor(ctx, centerX, centerY, scale, time, true); ctx.fillStyle = "#FFFFFF"; ctx.font = `bold ${scale * 0.15}px Orbitron`; ctx.textAlign = "center"; ctx.textBaseline = "middle"; ctx.shadowBlur = 0; ctx.fillText("JARVIS", 0, 0); drawMenu(); }
            if(visionActive) {
                const arCvs = document.getElementById('vision-ar-canvas'); const arCtx = arCvs.getContext('2d');
                arCtx.setTransform(1,0,0,1,0,0); arCtx.clearRect(0,0, arCvs.width, arCvs.height);
                if (isModelLoaded && document.getElementById('local-vision-feed').readyState === 4) {
                    const video = document.getElementById('local-vision-feed');
                    try {
                        const predictions = await faceModel.estimateFaces(video, false);
                        if (predictions.length > 0) {
                            const pred = predictions[0];
                            const vidW = video.videoWidth; const vidH = video.videoHeight; const cvsW = arCvs.width; const cvsH = arCvs.height;
                            const scaleFit = Math.max(cvsW / vidW, cvsH / vidH); const xOff = (cvsW - vidW * scaleFit) / 2; const yOff = (cvsH - vidH * scaleFit) / 2;
                            const startX = pred.topLeft[0]; const startY = pred.topLeft[1]; const endX = pred.bottomRight[0]; const endY = pred.bottomRight[1];
                            const faceX = (startX * scaleFit) + xOff + ((endX - startX) * scaleFit / 2); const faceY = (startY * scaleFit) + yOff + ((endY - startY) * scaleFit / 2);
                            let targetX = faceX; if (camFacingMode === 'user') targetX = cvsW - faceX;
                            
                            const smoothFactor = 0.12; 
                            if (!lockedTarget.active) { 
                                lockedTarget.x = targetX; 
                                lockedTarget.y = faceY; 
                                lockedTarget.active = true; 
                                lockedTarget.identity = { name: "UNKNOWN", rel: "ANALYZING...", color: "#FFA500" }; 
                                analyzeFace(video, pred); 
                            } 
                            else { 
                                lockedTarget.x += (targetX - lockedTarget.x) * smoothFactor;
                                lockedTarget.y += (faceY - lockedTarget.y) * smoothFactor;
                            }
                            lockedTarget.lastSeen = time;
                        } else {
                            if (time - lockedTarget.lastSeen > 60) { 
                                lockedTarget.x += (centerX - lockedTarget.x) * 0.02;
                                lockedTarget.y += (centerY - lockedTarget.y) * 0.02;

                                if(Math.abs(lockedTarget.x - centerX) < 10 && Math.abs(lockedTarget.y - centerY) < 10) {
                                     lockedTarget.active = false; 
                                     document.getElementById('vision-status').innerText = "SYSTEM ONLINE"; 
                                     document.getElementById('vision-status').style.color = "var(--primary)"; 
                                }
                            }
                        }
                        if (lockedTarget.active) drawTacticalHUD(arCtx, lockedTarget.x, lockedTarget.y, 60, time*2, lockedTarget.identity.color, lockedTarget.identity.name, lockedTarget.identity.rel);
                    } catch (err) {}
                }
            }
            time++; animationFrame = requestAnimationFrame(draw);
        }

        async function analyzeFace(video, pred) {
            if (lockedTarget.identity.color === "#00FF00" || isAnalyzing) return;
            isAnalyzing = true; document.getElementById('vision-status').innerText = "BIOMETRIC ANALYSIS...";
            await new Promise(r => setTimeout(r, 100));
            if (facesDB.length > 0) {
                const result = tf.tidy(() => {
                    const startX = Math.max(0, pred.topLeft[0]); const startY = Math.max(0, pred.topLeft[1]);
                    const width = pred.bottomRight[0] - startX; const height = pred.bottomRight[1] - startY;
                    if (width <= 0 || height <= 0) return null;
                    const videoTensor = tf.browser.fromPixels(video);
                    const faceTensor = videoTensor.slice([parseInt(startY), parseInt(startX), 0], [parseInt(height), parseInt(width), 3]);
                    const resized = tf.image.resizeBilinear(faceTensor, [224, 224]);
                    const embedding = recogModel.infer(resized, true);
                    let maxSim = -1; let matchIndex = -1;
                    for(let i=0; i<facesDB.length; i++) {
                        if(!facesDB[i].embedding) continue;
                        const dbTensor = tf.tensor(facesDB[i].embedding);
                        const dot = embedding.mul(dbTensor).sum();
                        const normA = embedding.norm(); const normB = dbTensor.norm();
                        const sim = dot.div(normA.mul(normB)).dataSync()[0];
                        if(sim > maxSim) { maxSim = sim; matchIndex = i; }
                    }
                    return { index: matchIndex, score: maxSim };
                });
                if (result && result.score > 0.82) {
                    const p = facesDB[result.index]; lockedTarget.identity = { name: `ID: ${p.name.toUpperCase()}`, rel: `ACCESS: ${p.rel.toUpperCase()}`, color: "#00FF00" };
                    document.getElementById('vision-status').innerText = "IDENTITY VERIFIED"; document.getElementById('vision-status').style.color = "#00FF00"; sfx('click');
                } else {
                    lockedTarget.identity = { name: "UNKNOWN", rel: "ACCESS: DENIED", color: "#FF0000" };
                    document.getElementById('vision-status').innerText = "UNKNOWN SUBJECT"; document.getElementById('vision-status').style.color = "#FF0000";
                }
            } else { lockedTarget.identity = { name: "UNKNOWN", rel: "NO DATABASE", color: "#FF0000" }; }
            isAnalyzing = false;
        }

        function drawMenu() {
            menuItems.forEach(item => {
                const outerR = scale * 1.6; const innerR = scale * 1.35; 
                const angleWidth = 0.25; 
                const startAngle = item.angle - angleWidth; const endAngle = item.angle + angleWidth;
                
                ctx.save(); ctx.beginPath(); 
                ctx.arc(0, 0, outerR, startAngle, endAngle); 
                ctx.arc(0, 0, innerR, endAngle, startAngle, true); ctx.closePath();
                
                if (item.target === 'sub-toggle' && mediaSubMenuOpen) ctx.fillStyle = "rgba(0, 229, 255, 0.3)";
                else ctx.fillStyle = "rgba(0, 10, 20, 0.8)"; 
                
                ctx.fill(); ctx.strokeStyle = '#00E5FF'; ctx.lineWidth = 1; ctx.stroke();
                
                const midR = (outerR + innerR) / 2; 
                const txtX = Math.cos(item.angle) * midR; const txtY = Math.sin(item.angle) * midR;
                ctx.fillStyle = "#00E5FF"; ctx.font = `bold ${scale * 0.08}px Orbitron`; 
                ctx.textAlign = "center"; ctx.textBaseline = "middle"; 
                ctx.fillText(item.label, txtX, txtY); ctx.restore();
            });

            if (mediaSubMenuOpen) {
                subMenuItems.forEach(item => {
                    const outerR = scale * 1.3; const innerR = scale * 1.05; 
                    const angleWidth = 0.15; 
                    const startAngle = item.angle - angleWidth; const endAngle = item.angle + angleWidth;

                    ctx.save(); ctx.beginPath(); 
                    ctx.arc(0, 0, outerR, startAngle, endAngle); 
                    ctx.arc(0, 0, innerR, endAngle, startAngle, true); ctx.closePath();
                    
                    ctx.fillStyle = "rgba(0, 40, 60, 0.9)"; 
                    ctx.fill(); ctx.strokeStyle = '#00E5FF'; ctx.lineWidth = 1; ctx.stroke();
                    
                    const midR = (outerR + innerR) / 2; 
                    const txtX = Math.cos(item.angle) * midR; const txtY = Math.sin(item.angle) * midR;
                    ctx.fillStyle = "#00E5FF"; ctx.font = `bold ${scale * 0.06}px Orbitron`; 
                    ctx.textAlign = "center"; ctx.textBaseline = "middle"; 
                    ctx.fillText(item.label, txtX, txtY); ctx.restore();
                });
            }
        }

        /* --- UTILS --- */
        function handleMediaSelect(input) { const files = Array.from(input.files); if (files.length === 0) return; files.forEach(f => saveTrackToDB(f)); files.forEach(f => playlist.push(f)); renderPlaylist(); if (currentTrackIndex === -1) playTrack(0); }
        function renderPlaylist() { const container = document.getElementById('playlist-container'); container.innerHTML = ''; if(playlist.length === 0) { container.innerHTML = '<div style="text-align:center; padding: 20px; color: #444; font-size: 12px;">PLAYLIST EMPTY</div>'; return; } playlist.forEach((track, index) => { const item = document.createElement('div'); item.className = 'track-item' + (index === currentTrackIndex ? ' active-track' : ''); item.onclick = () => playTrack(index); item.innerHTML = `<div class="track-icon"><i class="fas ${index === currentTrackIndex ? 'fa-volume-up' : 'fa-music'}"></i></div><div style="flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">${track.name}</div>`; container.appendChild(item); }); }
        function playTrack(index) { if (index < 0 || index >= playlist.length) return; currentTrackIndex = index; const track = playlist[index]; const player = document.getElementById('audio-player'); player.src = URL.createObjectURL(track); player.play(); document.getElementById('now-playing').innerText = track.name.toUpperCase(); renderPlaylist(); const activeEl = document.querySelector('.active-track'); if(activeEl) activeEl.scrollIntoView({ behavior: 'smooth', block: 'center' }); }
        function playNextTrack() { if (currentTrackIndex < playlist.length - 1) playTrack(currentTrackIndex + 1); else playTrack(0); }
        function activateHUD() { 
            hudActive = true; 
            document.getElementById('moto-hud').style.display = 'flex'; 
            // Trigger a resize to ensure HUD Canvas is correctly sized
            resize(); 
            requestFullScreen(); 
            if ('geolocation' in navigator) { 
                watchId = navigator.geolocation.watchPosition((pos) => { 
                    let s = pos.coords.speed; 
                    if(s === null || s < 0) s = 0; 
                    hudData.speed = Math.round(s * 3.6); 
                    if(pos.coords.altitude) hudData.alt = pos.coords.altitude; // CAPTURE ALTITUDE
                }, (err) => { }, { enableHighAccuracy: true, maximumAge: 0 }); 
            } 
            window.addEventListener('deviceorientation', handleOrientation); 
            updateClock(); 
            setInterval(updateClock, 1000); 
        }
        function closeHUD() { hudActive = false; document.getElementById('moto-hud').style.display = 'none'; if (watchId) navigator.geolocation.clearWatch(watchId); window.removeEventListener('deviceorientation', handleOrientation); resize(); draw(); }
        
        function handleOrientation(e) { 
            if (!hudActive) return; 
            // Store orientation in global object for Canvas loop
            hudData.alpha = e.alpha || 0; 
            hudData.beta = e.beta || 0; 
            hudData.gamma = e.gamma || 0; 
            
            // Update Compass Tape (Top) - Keeping it as redundancy
            const offset = (hudData.alpha / 360) * 100; 
            document.getElementById('hud-compass').style.transform = `translateX(${-offset}%)`; 
        }
        
        function updateClock() { const d = new Date(); document.getElementById('hud-clock').innerText = `${String(d.getHours()).padStart(2,'0')}:${String(d.getMinutes()).padStart(2,'0')}`; }
        function launchMaps() { window.open("https://maps.google.com", "_blank"); }
        function toggleVision() { visionActive = !visionActive; const vContainer = document.getElementById('vision-container'); const errorMsg = document.getElementById('cam-error-msg'); const video = document.getElementById('local-vision-feed'); if (visionActive) { vContainer.style.display = 'flex'; errorMsg.style.display = 'none'; video.style.display = 'block'; resize(); startCamera(); sfx('click'); } else { vContainer.style.display = 'none'; stopCamera(); } }
        function closeVision() { visionActive = false; document.getElementById('vision-container').style.display = 'none'; stopCamera(); sfx('close'); }
        async function startCamera() { try { localStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: camFacingMode } }); const video = document.getElementById('local-vision-feed'); video.srcObject = localStream; if(camFacingMode === 'user') video.classList.add('mirrored'); else video.classList.remove('mirrored'); } catch(e) { document.getElementById('local-vision-feed').style.display = 'none'; document.getElementById('cam-error-msg').style.display = 'block'; speak("Visual sensors failing."); } }
        function stopCamera() { if(localStream) { localStream.getTracks().forEach(t => t.stop()); localStream = null; } }
        function toggleCameraSource() { stopCamera(); camFacingMode = (camFacingMode === 'environment') ? 'user' : 'environment'; startCamera(); }
        async function takePhoto() { sfx('click'); const video = document.getElementById('local-vision-feed'); const cvs = document.createElement('canvas'); cvs.width = video.videoWidth; cvs.height = video.videoHeight; const ctx = cvs.getContext('2d'); if(camFacingMode === 'user') { ctx.translate(cvs.width, 0); ctx.scale(-1, 1); } ctx.drawImage(video, 0, 0); const imgData = cvs.toDataURL('image/jpeg'); document.getElementById('db-preview').src = imgData; document.getElementById('db-name').value = ""; document.getElementById('db-relation').value = ""; document.getElementById('modal-db').classList.add('active'); if(isModelLoaded) { document.getElementById('signature-status').innerText = "ANALYZING FACE GEOMETRY..."; document.getElementById('signature-status').style.color = "#FFA500"; const predictions = await faceModel.estimateFaces(cvs, false); if(predictions.length > 0) { const startX = predictions[0].topLeft[0]; const startY = predictions[0].topLeft[1]; const width = predictions[0].bottomRight[0] - startX; const height = predictions[0].bottomRight[1] - startY; tf.tidy(() => { const tensor = tf.browser.fromPixels(cvs); const faceT = tensor.slice([parseInt(startY), parseInt(startX), 0], [parseInt(height), parseInt(width), 3]); const resized = tf.image.resizeBilinear(faceT, [224, 224]); const resultTensor = recogModel.infer(resized, true); pendingEmbedding = resultTensor.arraySync(); }); document.getElementById('signature-status').innerText = "BIOMETRIC SIGNATURE ACQUIRED"; document.getElementById('signature-status').style.color = "#00FF00"; document.getElementById('btn-save-id').disabled = false; } else { document.getElementById('signature-status').innerText = "NO FACE DETECTED. RETRY."; document.getElementById('signature-status').style.color = "red"; document.getElementById('btn-save-id').disabled = true; } } }
        async function toggleRecord() { if(isRecording) { mediaRecorder.stop(); isRecording = false; document.getElementById('btn-record').classList.remove('recording'); speak("Recording saved."); } else { if(!localStream) return; recordedChunks = []; mediaRecorder = new MediaRecorder(localStream); mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); }; mediaRecorder.onstop = () => { const blob = new Blob(recordedChunks, { type: 'video/webm' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.style.display = 'none'; a.href = url; a.download = 'jarvis_recon_' + Date.now() + '.webm'; document.body.appendChild(a); a.click(); setTimeout(() => { document.body.removeChild(a); window.URL.revokeObjectURL(url); }, 100); }; mediaRecorder.start(); isRecording = true; document.getElementById('btn-record').classList.add('recording'); speak("Recording started."); } }
        function saveIdentity() { const name = document.getElementById('db-name').value; const rel = document.getElementById('db-relation').value; const img = document.getElementById('db-preview').src; if(!name || !pendingEmbedding) return; facesDB.push({ name, rel, img, embedding: pendingEmbedding }); localStorage.setItem('jarvis_faces', JSON.stringify(facesDB)); speak("Identity confirmed and encrypted."); loadFaceDB(); closeModal('modal-db'); }
        function loadFaceDB() { const list = document.getElementById('db-list'); list.innerHTML = ""; facesDB.forEach(p => { list.innerHTML += `<div class="db-entry"><img src="${p.img}" class="db-img"><div><div style="font-weight:bold;">${p.name}</div><div style="font-size:10px; opacity:0.7;">${p.rel}</div></div></div>`; }); }
        function clearDB() { facesDB = []; localStorage.removeItem('jarvis_faces'); loadFaceDB(); speak("Database wiped."); }
        
        function launchApp(url) { 
            speak("Establishing uplink."); 
            if (url.startsWith('http')) { window.open(url, '_blank'); } 
            else { window.location.href = url; }
        }
        
        function handleInput(e) { 
            if(hudActive || visionActive || document.querySelector('.modal-window.active')) return; 
            touchActive = e.type === 'touchstart'; 
            const cx = touchActive ? e.touches[0].clientX : e.clientX; 
            const cy = touchActive ? e.touches[0].clientY : e.clientY; 
            const rect = canvas.getBoundingClientRect(); 
            const dx = cx - (rect.left + centerX); 
            const dy = cy - (rect.top + centerY); 
            const dist = Math.sqrt(dx*dx + dy*dy); 
            const angle = Math.atan2(dy, dx); 

            if (dist > scale * 1.35 && dist < scale * 1.6) { 
                menuItems.forEach(item => { 
                    let diff = angle - item.angle; 
                    while(diff < -Math.PI) diff += Math.PI*2; 
                    while(diff > Math.PI) diff -= Math.PI*2; 
                    if (Math.abs(diff) < 0.25) { 
                        e.preventDefault(); 
                        sfx('click'); 
                        if(item.target === 'vision-toggle') toggleVision(); 
                        else if(item.target === 'hud-launch') activateHUD();
                        else if(item.target === 'sub-toggle') { mediaSubMenuOpen = !mediaSubMenuOpen; } 
                        else openModal(item.target); 
                    } 
                }); 
            }
            else if (dist > scale * 1.05 && dist < scale * 1.3 && mediaSubMenuOpen) {
                subMenuItems.forEach(item => {
                    let diff = angle - item.angle; 
                    while(diff < -Math.PI) diff += Math.PI*2; 
                    while(diff > Math.PI) diff -= Math.PI*2; 
                    if (Math.abs(diff) < 0.15) { 
                        e.preventDefault(); sfx('click'); 
                        openModal(item.target); 
                    }
                });
            }
            else if (dist < scale * 0.4) toggleVoiceInput(); 
        }

        let touchActive = false; window.addEventListener('touchstart', handleInput, {passive: false}); window.addEventListener('mousedown', (e) => { if(!touchActive) handleInput(e); });
        function openModal(id) { document.getElementById(id).classList.add('active'); sfx('click'); }
        function closeModal(id) { document.getElementById(id).classList.remove('active'); sfx('close'); }
        function closeAllModals() { document.querySelectorAll('.modal-window').forEach(m => m.classList.remove('active')); }
        function sfx(type) { const osc = audioCtx.createOscillator(); const gain = audioCtx.createGain(); osc.connect(gain); gain.connect(audioCtx.destination); if(type === 'startup') { osc.frequency.setValueAtTime(200, audioCtx.currentTime); osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.5); gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5); osc.start(); osc.stop(audioCtx.currentTime + 0.5); } else { osc.frequency.value = 1200; gain.gain.value = 0.05; osc.type = 'square'; osc.start(); osc.stop(audioCtx.currentTime + 0.05); } }
        function speak(text) { if (window.speechSynthesis) { const u = new SpeechSynthesisUtterance(text); const voices = speechSynthesis.getVoices(); const brit = voices.find(v => v.name.includes('Great Britain') || v.name.includes('UK') && v.name.includes('Male')); if (brit) u.voice = brit; speechSynthesis.speak(u); } }
        
        // --- ADVANCED VOICE CONTROL ---
        function initSpeech() { 
            const SR = window.SpeechRecognition || window.webkitSpeechRecognition; 
            if(!SR) return; 
            recognition = new SR(); 
            recognition.continuous = false; // RESTART MANUALLY FOR STABILITY
            recognition.interimResults = false;
            recognition.lang = 'en-GB'; 
            
            recognition.onresult = (e) => { 
                const last = e.results.length - 1;
                const cmd = e.results[last][0].transcript.toLowerCase().trim();
                console.log("Command:", cmd);

                // --- COMMAND PRIORITY: CHECK CLOSE FIRST ---
                
                // CLOSE COMMANDS
                if(cmd.includes('close hud') || cmd.includes('kill hud')) { speakRandomConfirm(); closeHUD(); }
                else if(cmd.includes('close vision') || cmd.includes('stop camera')) { speakRandomConfirm(); if(visionActive) closeVision(); }
                else if(cmd.includes('close media') || cmd.includes('close music')) { speakRandomConfirm(); closeModal('modal-media'); }
                else if(cmd.includes('close settings') || cmd.includes('close config')) { speakRandomConfirm(); closeModal('modal-settings'); }
                else if(cmd.includes('close database') || cmd.includes('close identity')) { speakRandomConfirm(); closeModal('modal-db'); }
                else if(cmd.includes('close comms') || cmd.includes('close social')) { speakRandomConfirm(); closeModal('modal-comms'); }
                else if(cmd.includes('close')) { speakRandomConfirm(); closeAllModals(); } // Generic close

                // OPEN COMMANDS
                else if(cmd.includes('open hud') || cmd.includes('start hud')) { speakRandomConfirm(); activateHUD(); }
                else if(cmd.includes('vision') || cmd.includes('camera') || cmd.includes('eyes')) { speakRandomConfirm(); if(!visionActive) toggleVision(); }

                else if(cmd.includes('comms') || cmd.includes('social')) { speakRandomConfirm(); openModal('modal-comms'); }
                else if(cmd.includes('whatsapp')) { launchApp('whatsapp://send?text='); }
                else if(cmd.includes('facebook')) { launchApp('https://m.facebook.com/'); }
                else if(cmd.includes('messenger')) { launchApp('https://m.me/'); }
                else if(cmd.includes('instagram')) { launchApp('https://www.instagram.com/'); }

                // MEDIA COMMANDS
                else if(cmd.includes('media') || cmd.includes('music') || cmd.includes('player')) { speakRandomConfirm(); openModal('modal-media'); }
                else if(cmd.includes('play')) { 
                    const player = document.getElementById('audio-player');
                    if (playlist.length > 0) {
                        if(!player.src || player.src === "") playTrack(0); // If no track loaded, load first
                        else player.play();
                    } else {
                        speak("Playlist empty, Sir.");
                    }
                }
                else if(cmd.includes('pause') || cmd.includes('stop')) { document.getElementById('audio-player').pause(); }
                else if(cmd.includes('next') || cmd.includes('skip')) { playNextTrack(); }
                else if(cmd.includes('clear playlist')) { clearMediaDB(); }

                else if(cmd.includes('database') || cmd.includes('identity')) { speakRandomConfirm(); openModal('modal-db'); }
                
                else if(cmd.includes('full screen')) { requestFullScreen(); }
                else if(cmd.includes('status') || cmd.includes('report')) { speak("All systems nominal. Battery at " + Math.round(Math.random()*20+80) + " percent."); }
            };

            // FORCE RESTART LOOP
            recognition.onend = () => { 
                console.log("RESTARTING LISTENER...");
                try { recognition.start(); } catch(e) {} 
            };
            
            try { recognition.start(); } catch(e) {} 
        }

        function speakRandomConfirm() {
            const phrases = ["Right away, Sir.", "Processing.", "On it, Sir.", "Affirmative.", "Executing."];
            speak(phrases[Math.floor(Math.random() * phrases.length)]);
        }

        function toggleVoiceInput() { try { recognition.start(); } catch(e) {} }
        function saveApiKey(val) { systemConfig.apiKey = val.trim(); localStorage.setItem('jarvis_api_key', val); }
    </script>
</body>
</html>


